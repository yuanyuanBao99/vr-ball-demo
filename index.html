<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>VR Ball Motion</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script>
      // 工具：从路标（waypoints）子节点读取点
      function readWaypoints(el) {
        const pts = [];
        el.querySelectorAll('[position]').forEach(n => {
          const p = n.getAttribute('position');
          pts.push(new THREE.Vector3(p.x, p.y, p.z));
        });
        return pts;
      }

      // 自定义组件：path-move
      AFRAME.registerComponent('path-move', {
        schema: {
          speed: { type: 'number', default: 1.0 },        // m/s
          duration: { type: 'number', default: 0 },        // 总时长(s)，0=不限
          loop: { type: 'boolean', default: true },
          trajectory: { type: 'string', default: 'circle'},// circle | lissajous | spline | random
          bounds: { type: 'vec3', default: {x:4,y:2,z:4}}, // 运动盒尺寸（反弹）
          useBounds: { type: 'boolean', default: false },  // 是否启用范围限制
          // 轨迹参数
          radius: { type: 'number', default: 1.5 },        // circle半径
          lissaAx: { type:'number', default: 1.2 },
          lissaAy: { type:'number', default: 0.8 },
          lissaAz: { type:'number', default: 1.0 },
          lissaFx: { type:'number', default: 1.0 },
          lissaFy: { type:'number', default: 1.5 },
          lissaFz: { type:'number', default: 0.5 },
          center: { type: 'vec3', default: {x:0,y:1.2,z:-2}}
        },
        init() {
          this.t = 0; // 已运动时间
          this.dir = new THREE.Vector3(1,0.3,0.7).normalize(); // random用
          this.velocity = new THREE.Vector3();
          this.startTime = null;
          this.spline = null;

          // 如果用户提供了 #waypoints（子实体里放若干 <a-entity position="...">）
          const wp = document.querySelector('#waypoints');
          if (wp && this.data.trajectory === 'spline') {
            const pts = readWaypoints(wp);
            if (pts.length >= 2) {
              this.spline = new THREE.CatmullRomCurve3(pts, true, 'centripetal', 0.5);
              // 可视化轨迹（可选）
              const geo = new THREE.BufferGeometry().setFromPoints(this.spline.getPoints(200));
              const mat = new THREE.LineBasicMaterial({color: 0x888888});
              const line = new THREE.Line(geo, mat);
              wp.object3D.add(line);
            }
          }
        },
        tick(time, timeDelta) {
          if (this.startTime === null) this.startTime = time;
          const dt = timeDelta / 1000; // 秒
          this.t += dt;

          // 超时处理
          if (this.data.duration > 0 && this.t >= this.data.duration) {
            if (this.data.loop) {
              this.t = 0;
            } else {
              return; // 停止更新
            }
          }

          // 根据轨迹计算目标位置
          const pos = this.el.object3D.position;
          const d = this.data;
          let target = new THREE.Vector3();

          if (d.trajectory === 'circle') {
            // 等角速度：速度 v = radius * omega => omega = v / r
            const r = Math.max(0.001, d.radius);
            const omega = d.speed / r;
            const a = omega * this.t;
            target.set(
              d.center.x + r * Math.cos(a),
              d.center.y,
              d.center.z + r * Math.sin(a)
            );
            pos.copy(target);
            return;
          }

          if (d.trajectory === 'lissajous') {
            // Lissajous 3D：x = Ax sin(fx t), ...
            const t = this.t;
            target.set(
              d.center.x + d.lissaAx * Math.sin(d.lissaFx * t),
              d.center.y + d.lissaAy * Math.sin(d.lissaFy * t + Math.PI/2),
              d.center.z + d.lissaAz * Math.sin(d.lissaFz * t + Math.PI/3)
            );
            // 根据实际速度校正（可选：这里简单直接设位）
            pos.copy(target);
            return;
          }

          if (d.trajectory === 'spline' && this.spline) {
            // 沿样条均匀运动：用弧长参数化的近似（简单法）
            if (!this.arcLen) {
              const samples = 200;
              this.arcLen = {u: [0], s: [0], total:0};
              let prev = this.spline.getPoint(0);
              for (let i=1;i<=samples;i++){
                const u = i/samples;
                const p = this.spline.getPoint(u);
                this.arcLen.u.push(u);
                const ds = p.distanceTo(prev);
                this.arcLen.s.push(this.arcLen.s[this.arcLen.s.length-1]+ds);
                prev = p;
              }
              this.arcLen.total = this.arcLen.s[this.arcLen.s.length-1];
            }
            const dist = (this.t * d.speed) % this.arcLen.total;
            // 二分查找 dist 对应的 u
            let lo=0, hi=this.arcLen.s.length-1;
            while (lo<hi){
              const mid=(lo+hi)>>1;
              if (this.arcLen.s[mid] < dist) lo=mid+1; else hi=mid;
            }
            const i = Math.max(1, lo);
            const s0 = this.arcLen.s[i-1], s1 = this.arcLen.s[i];
            const u0 = this.arcLen.u[i-1], u1 = this.arcLen.u[i];
            const u = (s1===s0) ? u0 : u0 + (dist - s0) * (u1 - u0) / (s1 - s0);
            target.copy(this.spline.getPoint(u));
            pos.copy(target);
            return;
          }

          if (d.trajectory === 'random') {
            // 随机游走 + 速度控制 + 反弹边界
            // 每隔一段时间轻微改变方向
            if (!this.noiseT) this.noiseT = 0;
            this.noiseT += dt;
            if (this.noiseT > 0.4) {
              this.noiseT = 0;
              const jitter = new THREE.Vector3(
                (Math.random()-0.5)*0.5,
                (Math.random()-0.5)*0.5,
                (Math.random()-0.5)*0.5
              );
              this.dir.add(jitter).normalize();
            }
            this.velocity.copy(this.dir).multiplyScalar(d.speed);
            pos.addScaledVector(this.velocity, dt);

            if (d.useBounds) {
              // 以 center 为原点的盒限制
              const min = new THREE.Vector3(
                d.center.x - d.bounds.x/2,
                d.center.y - d.bounds.y/2,
                d.center.z - d.bounds.z/2
              );
              const max = new THREE.Vector3(
                d.center.x + d.bounds.x/2,
                d.center.y + d.bounds.y/2,
                d.center.z + d.bounds.z/2
              );
              if (pos.x < min.x || pos.x > max.x) { this.dir.x *= -1; pos.x = THREE.MathUtils.clamp(pos.x, min.x, max.x); }
              if (pos.y < min.y || pos.y > max.y) { this.dir.y *= -1; pos.y = THREE.MathUtils.clamp(pos.y, min.y, max.y); }
              if (pos.z < min.z || pos.z > max.z) { this.dir.z *= -1; pos.z = THREE.MathUtils.clamp(pos.z, min.z, max.z); }
            }
          }
        },
        // 公开 API（可在外部脚本里调用）
        pause() { this._paused = true; },
        play()  { this._paused = false; },
      });
    </script>
  </head>
  <body>
    <a-scene renderer="colorManagement:true" xr-mode-ui="enabled: true">
      <a-entity position="0 1.6 0" camera look-controls wasd-controls="acceleration:0"></a-entity>

      <!-- 环境 -->
      <a-sky color="#ECECEC"></a-sky>
      <a-plane rotation="-90 0 0" width="20" height="20" color="#CFCFCF"></a-plane>

      <!-- 样条路标（可选，仅当 trajectory: spline 时使用） -->
      <a-entity id="waypoints" position="0 1 -2" visible="false">
        <a-entity position="-1 0  0"></a-entity>
        <a-entity position=" 1 0  0"></a-entity>
        <a-entity position=" 1 0 -2"></a-entity>
        <a-entity position="-1 0 -2"></a-entity>
      </a-entity>

      <!-- 小球（换不同轨迹只改 path-move 的参数） -->
      <a-sphere radius="0.12" color="#4CC3D9"
        path-move="trajectory: circle; speed: 1.2; radius: 1.4; center: 0 1.2 -2; duration: 0; loop: true">
      </a-sphere>

      <!-- 可换成 Lissajous -->
      <!-- <a-sphere radius="0.12" color="#EF2D5E"
        path-move="trajectory: lissajous; speed: 1.0; lissaAx:1.3; lissaAy:0.8; lissaAz:1.2; center: 0 1.2 -2">
      </a-sphere> -->

      <!-- 可换成 Spline -->
      <!-- <a-sphere radius="0.12" color="#7BC8A4"
        path-move="trajectory: spline; speed: 0.8; center: 0 1 -2">
      </a-sphere> -->

      <!-- 可换成 随机 + 边界盒反弹 -->
      <!-- <a-sphere radius="0.12" color="#FFC65D"
        path-move="trajectory: random; speed: 0.8; center: 0 1.2 -2; useBounds: true; bounds: 3 1.5 3">
      </a-sphere> -->
    </a-scene>
  </body>
</html>
