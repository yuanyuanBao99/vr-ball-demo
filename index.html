<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>VR Ball with Speed Curve (A-Frame)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- 在线版：可换成本地 libs/aframe.min.js -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <style>
      .panel {
        position: fixed; left: 12px; top: 12px; z-index: 9999;
        background: rgba(255,255,255,.9); padding: 10px 12px; border-radius: 10px;
        font: 14px/1.4 system-ui, -apple-system, "Segoe UI", Roboto, Arial;
        box-shadow: 0 8px 24px rgba(0,0,0,.1); max-width: 320px;
      }
      .row { margin: 8px 0; }
      .row label { display:block; font-weight:600; margin-bottom:4px; }
      .row input[type="range"] { width:100%; }
      .row input[type="number"], .row select { width:100%; box-sizing:border-box; }
      .row textarea { width:100%; height:96px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
      .muted { color:#666; font-size:12px; }
      .inline { display:flex; gap:8px; align-items:center; }
      .inline > * { flex:1; }
      .ok { color:#0a7; font-weight:600; }
      .err { color:#c00; font-weight:600; }
    </style>

    <script>
      // —— 工具：线性插值 & 包裹取模
      const clamp01 = x => Math.max(0, Math.min(1, x));
      const lerp = (a,b,t) => a + (b-a)*t;
      const wrap = (x, L) => { if (L<=0) return 0; x%=L; return x<0? x+L : x; };

      // —— 速度曲线求值器
      // mode = 'constant' | 'sine' | 'keyframes'
      class SpeedCurve {
        constructor(opts){
          this.mode = opts.mode || 'constant';
          this.base = opts.base ?? 1.2;         // m/s
          this.amp  = opts.amp  ?? 0.6;         // m/s
          this.freq = opts.freq ?? 0.5;         // Hz
          this.phase= opts.phase?? 0.0;         // rad
          this.kf   = Array.isArray(opts.keyframes) ? opts.keyframes.slice() : []; // [[t,speed],...]
          this.kf.sort((a,b)=>a[0]-b[0]);
          this._dur = this.kf.length>0 ? this.kf[this.kf.length-1][0] : 0;
        }
        get duration(){ return this._dur; }

        eval(tSec){
          if (this.mode === 'constant'){
            return Math.max(0, this.base);
          }
          if (this.mode === 'sine'){
            // v(t) = base + amp * sin(2π f t + phase)
            return Math.max(0, this.base + this.amp * Math.sin(2*Math.PI*this.freq*tSec + this.phase));
          }
          if (this.mode === 'keyframes'){
            if (this.kf.length===0) return Math.max(0, this.base);
            const T = this._dur;
            const tt = T>0 ? wrap(tSec, T) : 0;
            // 找到 tt 所在的段
            let i=1;
            while (i<this.kf.length && this.kf[i][0] < tt) i++;
            const p1 = this.kf[i % this.kf.length];
            const p0 = this.kf[(i-1 + this.kf.length)%this.kf.length];
            const t0 = p0[0], s0 = p0[1];
            const t1 = p1[0], s1 = p1[1];
            const span = (t1>t0) ? (t1-t0) : (t1 + T - t0); // 跨越末尾时包裹
            const dt = (tt>=t0) ? (tt - t0) : (tt + T - t0);
            const u = span>1e-6 ? dt/span : 0;
            return Math.max(0, lerp(s0, s1, clamp01(u)));
          }
          return Math.max(0, this.base);
        }
      }

      // —— 运动组件（先实现圆周轨迹 + 速度曲线）
      AFRAME.registerComponent('circle-with-speedcurve', {
        schema: {
          radius:  {type:'number', default: 1.4},     // 轨道半径 (m)
          center:  {type:'vec3',   default:{x:0,y:1.2,z:-2}},
          // 速度曲线参数（初始值；运行中可由 UI 改）
          mode:    {type:'string', default:'constant'}, // constant | sine | keyframes
          base:    {type:'number', default:1.2},
          amp:     {type:'number', default:0.6},
          freq:    {type:'number', default:0.5},
          phase:   {type:'number', default:0.0},
          // keyframes 通过外部 JSON 传入（见下方 UI），这里不放到 schema 里
        },
        init(){
          this.t = 0;                // 运行时间（秒）
          this.angle = 0;            // 当前角度（弧度）
          this.curve = new SpeedCurve({
            mode: this.data.mode,
            base: this.data.base,
            amp:  this.data.amp,
            freq: this.data.freq,
            phase:this.data.phase,
            keyframes:[]
          });
        },
        update(oldData){
          // 当属性变化时（例如 UI 改了），刷新曲线
          this.curve.mode  = this.data.mode;
          this.curve.base  = this.data.base;
          this.curve.amp   = this.data.amp;
          this.curve.freq  = this.data.freq;
          this.curve.phase = this.data.phase;
          // keyframes 由外部 setter 注入
        },
        tick(time, timeDelta){
          const dt = timeDelta/1000;
          this.t += dt;

          // 由速度曲线得到 v(t)，再积分角速度： dθ/dt = v/r
          const r = Math.max(0.001, this.data.radius);
          const v = this.curve.eval(this.t);     // m/s
          const omega = v / r;                   // rad/s
          this.angle += omega * dt;

          const cx = this.data.center.x, cy = this.data.center.y, cz = this.data.center.z;
          const x = cx + r * Math.cos(this.angle);
          const z = cz + r * Math.sin(this.angle);
          this.el.object3D.position.set(x, cy, z);
        },
        // 让外部能动态设置关键帧
        setKeyframes(arr){
          // arr: [[timeSec, speed], ...]，time 单调递增，speed>=0
          this.curve = new SpeedCurve({
            mode: 'keyframes',
            keyframes: arr
          });
          this.el.setAttribute('circle-with-speedcurve', 'mode', 'keyframes');
        }
      });

      // —— 绑定 UI
      window.addEventListener('DOMContentLoaded', ()=>{
        const sphere = document.querySelector('#ball');

        const modeSel = document.getElementById('mode');
        const baseInp = document.getElementById('base');
        const baseVal = document.getElementById('baseVal');
        const ampInp  = document.getElementById('amp');
        const ampVal  = document.getElementById('ampVal');
        const freqInp = document.getElementById('freq');
        const freqVal = document.getElementById('freqVal');
        const phaseInp= document.getElementById('phase');
        const phaseVal= document.getElementById('phaseVal');
        const kfArea  = document.getElementById('kfjson');
        const kfBtn   = document.getElementById('applyKf');
        const kfMsg   = document.getElementById('kfmsg');

        function apply(){
          sphere.setAttribute('circle-with-speedcurve', {
            mode: modeSel.value,
            base: parseFloat(baseInp.value),
            amp:  parseFloat(ampInp.value),
            freq: parseFloat(freqInp.value),
            phase:parseFloat(phaseInp.value)
          });
          baseVal.textContent = baseInp.value;
          ampVal.textContent  = ampInp.value;
          freqVal.textContent = freqInp.value;
          phaseVal.textContent= phaseInp.value;
        }
        [modeSel, baseInp, ampInp, freqInp, phaseInp].forEach(el=>{
          el.addEventListener('input', apply);
        });
        apply();

        kfBtn.addEventListener('click', ()=>{
          try{
            const arr = JSON.parse(kfArea.value);
            if (!Array.isArray(arr)) throw new Error('需要数组');
            // 简单校验
            for (const p of arr){
              if (!Array.isArray(p) || p.length!==2) throw new Error('每个关键帧应为 [timeSec, speed]');
              if (typeof p[0]!=='number' || typeof p[1]!=='number') throw new Error('time/speed 必须是数字');
              if (p[0]<0 || p[1]<0) throw new Error('time/speed 不能为负');
            }
            // 设置
            document.querySelector('#ball').components['circle-with-speedcurve'].setKeyframes(arr);
            kfMsg.textContent = '已应用关键帧 ✅';
            kfMsg.className = 'ok';
            modeSel.value = 'keyframes';
          }catch(e){
            kfMsg.textContent = '关键帧 JSON 有误：' + e.message;
            kfMsg.className = 'err';
          }
        });
      });
    </script>
  </head>
  <body>
    <!-- 控制面板 -->
    <div class="panel">
      <div class="row">
        <label>速度模式 (mode)</label>
        <select id="mode">
          <option value="constant">constant（常数）</option>
          <option value="sine">sine（正弦）</option>
          <option value="keyframes">keyframes（关键帧）</option>
        </select>
      </div>

      <div class="row">
        <label>base 速度（m/s）：<span id="baseVal">1.2</span></label>
        <input id="base" type="range" min="0" max="5" step="0.1" value="1.2">
      </div>

      <div class="row">
        <label>amp 幅度（m/s）：<span id="ampVal">0.6</span></label>
        <input id="amp" type="range" min="0" max="5" step="0.1" value="0.6">
      </div>

      <div class="row">
        <label>freq 频率（Hz）：<span id="freqVal">0.5</span></label>
        <input id="freq" type="range" min="0" max="2" step="0.05" value="0.5">
      </div>

      <div class="row">
        <label>phase 相位（rad）：<span id="phaseVal">0.0</span></label>
        <input id="phase" type="range" min="-6.283" max="6.283" step="0.01" value="0.0">
      </div>

      <div class="row">
        <label>关键帧 JSON（[timeSec, speed]，线性插值，自动循环）</label>
        <textarea id="kfjson">[
  [0,   0.4],
  [1.0, 2.0],
  [2.0, 0.8],
  [3.0, 3.5]
]</textarea>
        <div class="inline">
          <button id="applyKf">应用关键帧</button>
          <span id="kfmsg" class="muted">例：0s→0.4 m/s → 1s→2.0 m/s ...</span>
        </div>
      </div>

      <div class="row muted">
        小贴士：正弦模式下速度可能为负，已自动钳为 ≥ 0；关键帧会按最后一个 time 作为总时长循环。
      </div>
    </div>

    <!-- A-Frame 场景 -->
    <a-scene renderer="colorManagement:true" xr-mode-ui="enabled: true">
      <a-entity position="0 1.6 0" camera look-controls wasd-controls="acceleration:0"></a-entity>

      <a-sky color="#ECECEC"></a-sky>
      <a-plane rotation="-90 0 0" width="20" height="20" color="#CFCFCF"></a-plane>

      <!-- 小球：圆周轨迹 + 速度曲线 -->
      <a-sphere id="ball" radius="0.12" color="#4CC3D9"
        circle-with-speedcurve="radius: 1.4; center: 0 1.2 -2; mode: constant; base: 1.2; amp: 0.6; freq: 0.5; phase: 0.0;">
      </a-sphere>
    </a-scene>
  </body>
</html>
