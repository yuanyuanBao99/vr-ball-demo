<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>VR Ball — Trajectories + Launch + Lifetime</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- A-Frame (可换成本地 libs/aframe.min.js) -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>

    <style>
      .panel{
        position:fixed; left:12px; top:12px;
        z-index:999999;                       /* 确保面板在最上层 */
        background:rgba(255,255,255,.95);
        padding:12px; border-radius:12px;
        box-shadow:0 10px 30px rgba(0,0,0,.18);
        font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial;
        max-width:360px;
        pointer-events:auto;
      }
      html,body{ margin:0; padding:0; overflow:hidden; }

      .row{margin:8px 0}
      .row label{display:block;font-weight:600;margin-bottom:4px}
      .row input[type="range"]{width:100%}
      .row input[type="number"],.row select{width:100%;box-sizing:border-box}
      .row textarea{width:100%;height:96px;font-family:ui-monospace,Consolas,monospace}
      .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
      .muted{color:#666;font-size:12px}
      .ok{color:#0a7;font-weight:600}.err{color:#c00;font-weight:600}
    </style>

    <script>
      // ---------- 工具 ----------
      const clamp01 = x => Math.max(0, Math.min(1, x));
      const lerp = (a,b,t) => a + (b-a)*t;
      const wrap = (x,L)=>{ if(L<=0)return 0; x%=L; return x<0?x+L:x; };

      // ---------- 速度曲线 ----------
      class SpeedCurve{
        constructor(o={}){
          this.mode=o.mode||'constant';
          this.base=o.base??1.2; this.amp=o.amp??0.6; this.freq=o.freq??0.5; this.phase=o.phase??0;
          this.kf=Array.isArray(o.keyframes)?o.keyframes.slice():[];
          this.kf.sort((a,b)=>a[0]-b[0]); this._dur=this.kf.length?this.kf[this.kf.length-1][0]:0;
        }
        get duration(){return this._dur;}
        eval(t){
          if(this.mode==='constant') return Math.max(0,this.base);
          if(this.mode==='sine') return Math.max(0,this.base+this.amp*Math.sin(2*Math.PI*this.freq*t+this.phase));
          if(this.mode==='keyframes'){
            if(!this.kf.length) return Math.max(0,this.base);
            const T=this._dur, tt=T>0?wrap(t,T):0;
            let i=1; while(i<this.kf.length&&this.kf[i][0]<tt) i++;
            const p1=this.kf[i%this.kf.length], p0=this.kf[(i-1+this.kf.length)%this.kf.length];
            const [t0,s0]=p0,[t1,s1]=p1;
            const span=(t1>t0)?(t1-t0):(t1+T-t0), dt=(tt>=t0)?(tt-t0):(tt+T-t0);
            const u=span>1e-6?dt/span:0; return Math.max(0, lerp(s0,s1,clamp01(u)));
          }
          return Math.max(0,this.base);
        }
      }

      // ---------- 弧长 LUT（样条用） ----------
      function buildArcLUT(curve, samples=400){
        const u=[], s=[0]; u.push(0);
        let total=0, prev=curve.getPoint(0);
        for(let i=1;i<=samples;i++){
          const uu=i/samples, p=curve.getPoint(uu);
          total += p.distanceTo(prev);
          u.push(uu); s.push(total); prev=p;
        }
        return {u,s,total};
      }
      function uFromDistance(lut, dist){
        const {u,s,total}=lut;
        let d=wrap(dist,total);
        let lo=0, hi=s.length-1;
        while(lo<hi){
          const mid=(lo+hi)>>1;
          if(s[mid]<d) lo=mid+1; else hi=mid;
        }
        const i=Math.max(1,lo), s0=s[i-1], s1=s[i], u0=u[i-1], u1=u[i];
        if(s1===s0) return u0;
        return u0 + (d - s0) * (u1 - u0) / (s1 - s0);
      }

      // ---------- 统一运动组件（含：起点/跳出/寿命） ----------
      AFRAME.registerComponent('motion-with-speedcurve',{
        schema:{
          trajectory:{type:'string',default:'circle'}, // circle|lissajous|spline|random

          // 起点 & 跳出
          startPos:{type:'vec3',default:{x:-0.3,y:0.2,z:1.5}}, // 屏幕中心(0,0,1.5)左上
          useStartPos:{type:'boolean',default:true},
          launch:{type:'boolean',default:true},
          launchDuration:{type:'number',default:0.6},
          launchDistance:{type:'number',default:0.5},        // 沿 -Z

          // circle & lissajous 基准中心（会被 shift 到跳出后附近）
          center:{type:'vec3',default:{x:0,y:1.2,z:-2}},
          radius:{type:'number',default:1.4},

          // lissajous 参数
          lAx:{type:'number',default:1.2}, lAy:{type:'number',default:0.8}, lAz:{type:'number',default:1.0},
          lFx:{type:'number',default:1.0}, lFy:{type:'number',default:1.5}, lFz:{type:'number',default:0.6},

          // random 边界
          useBounds:{type:'boolean',default:true},
          bounds:{type:'vec3',default:{x:3,y:1.5,z:3}},

          // 速度曲线
          mode:{type:'string',default:'constant'}, base:{type:'number',default:1.2},
          amp:{type:'number',default:0.6}, freq:{type:'number',default:0.5}, phase:{type:'number',default:0},

          // 寿命
          lifetimeMin:{type:'number',default:3.0},
          lifetimeMax:{type:'number',default:6.0},
          vanishAction:{type:'string',default:'remove'} // remove | hide
        },

        init(){
          this.t=0; this.angle=0;
          this.curve=new SpeedCurve({mode:this.data.mode,base:this.data.base,amp:this.data.amp,freq:this.data.freq,phase:this.data.phase});

          const L=this.data;
          const life = L.lifetimeMin + Math.random() * Math.max(0, L.lifetimeMax - L.lifetimeMin);
          this.deathT = life;
          this.launchDone = !L.launch;

          // 初始位置
          if (L.useStartPos){
            this.start = new THREE.Vector3(L.startPos.x, L.startPos.y, L.startPos.z);
            this.el.object3D.position.copy(this.start);
          } else {
            this.start = this.el.object3D.position.clone();
          }

          // 跳出后的参考中心（沿 -Z 推）
          this.launchDir = new THREE.Vector3(0,0,-1);
          this.centerShifted = new THREE.Vector3(
            L.startPos.x, L.startPos.y, L.startPos.z - L.launchDistance
          );

          // random
          this.dir=new THREE.Vector3(1,0.3,0.7).normalize();
          this.noiseT=0;

          // spline
          this.spline=null; this.lut=null; this.sDist=0;
          const wp=document.querySelector('#waypoints');
          if(wp){
            const pts=[];
            wp.querySelectorAll('[position]').forEach(n=>{
              const p=n.getAttribute('position'); pts.push(new THREE.Vector3(p.x,p.y,p.z));
            });
            if(pts.length>=2){
              this.spline=new THREE.CatmullRomCurve3(pts,true,'centripetal',0.5);
              this.lut=buildArcLUT(this.spline,600);
              const geo=new THREE.BufferGeometry().setFromPoints(this.spline.getPoints(300));
              const mat=new THREE.LineBasicMaterial({color:0x888888});
              const line=new THREE.Line(geo,mat); wp.object3D.add(line);
            }
          }

          // 圆周和李萨如默认围绕“跳出后”的中心
          if (this.data.trajectory==='circle'){
            this.data.center = {x:this.centerShifted.x, y:this.centerShifted.y, z:this.centerShifted.z};
          }
        },

        update(){
          this.curve.mode=this.data.mode; this.curve.base=this.data.base;
          this.curve.amp=this.data.amp; this.curve.freq=this.data.freq; this.curve.phase=this.data.phase;
        },

        tick(time, timeDelta){
          const dt=timeDelta/1000; this.t+=dt;

          // 到时消失
          if (this.t >= this.deathT){
            if (this.data.vanishAction==='remove' && this.el.parentNode){
              this.el.parentNode.removeChild(this.el);
            } else {
              this.el.setAttribute('visible','false');
              this.pause();
            }
            return;
          }

          // Launch：沿 -Z 推出（easeOutCubic）
          if (!this.launchDone){
            const u = Math.min(1, this.t / Math.max(1e-6, this.data.launchDuration));
            const easeOutCubic = (x)=>1-Math.pow(1-x,3);
            const d = easeOutCubic(u) * this.data.launchDistance;
            const p = this.start.clone().addScaledVector(this.launchDir, d);
            this.el.object3D.position.copy(p);
            if (u>=1) {
              this.launchDone = true;
              if (this.data.trajectory==='circle'){
                const c=this.data.center;
                const dx=p.x-c.x, dz=p.z-c.z;
                this.angle = Math.atan2(dz, dx);
              }
            }
            return;
          }

          // 轨迹阶段
          const v=this.curve.eval(this.t);
          const c=this.data.center; const pos=this.el.object3D.position;

          if(this.data.trajectory==='circle'){
            const r=Math.max(0.001,this.data.radius);
            const omega=v/r; this.angle+=omega*dt;
            pos.set(c.x + r*Math.cos(this.angle), c.y, c.z + r*Math.sin(this.angle));
            return;
          }

          if(this.data.trajectory==='lissajous'){
            if(this.u===undefined) this.u=0;
            for(let k=0;k<2;k++){
              const du1=this._duForV(this.u,v,dt/2); this.u+=du1;
            }
            const x = this.centerShifted.x + this.data.lAx*Math.sin(this.data.lFx*this.u);
            const y = this.centerShifted.y + this.data.lAy*Math.sin(this.data.lFy*this.u + Math.PI/2);
            const z = this.centerShifted.z + this.data.lAz*Math.sin(this.data.lFz*this.u + Math.PI/3);
            pos.set(x,y,z);
            return;
          }

          if(this.data.trajectory==='spline' && this.spline && this.lut){
            this.sDist += v*dt;
            const u = uFromDistance(this.lut, this.sDist);
            const p = this.spline.getPoint(u);
            pos.copy(p);
            return;
          }

          if(this.data.trajectory==='random'){
            this.noiseT+=dt;
            if(this.noiseT>0.4){ this.noiseT=0;
              const j=new THREE.Vector3((Math.random()-0.5)*0.6,(Math.random()-0.5)*0.6,(Math.random()-0.5)*0.6);
              this.dir.add(j).normalize();
            }
            const step=v*dt; pos.addScaledVector(this.dir, step);
            if(this.data.useBounds){
              const min=new THREE.Vector3(this.centerShifted.x-this.data.bounds.x/2,this.centerShifted.y-this.data.bounds.y/2,this.centerShifted.z-this.data.bounds.z/2);
              const max=new THREE.Vector3(this.centerShifted.x+this.data.bounds.x/2,this.centerShifted.y+this.data.bounds.y/2,this.centerShifted.z+this.data.bounds.z/2);
              if(pos.x<min.x||pos.x>max.x){ this.dir.x*=-1; pos.x=THREE.MathUtils.clamp(pos.x,min.x,max.x); }
              if(pos.y<min.y||pos.y>max.y){ this.dir.y*=-1; pos.y=THREE.MathUtils.clamp(pos.y,min.y,max.y); }
              if(pos.z<min.z||pos.z>max.z){ this.dir.z*=-1; pos.z=THREE.MathUtils.clamp(pos.z,min.z,max.z); }
            }
            return;
          }
        },

        _duForV(u,v,dt){
          const Ax=this.data.lAx, Ay=this.data.lAy, Az=this.data.lAz;
          const fx=this.data.lFx, fy=this.data.lFy, fz=this.data.lFz;
          const dx = Ax*fx*Math.cos(fx*u);
          const dy = Ay*fy*Math.cos(fy*u + Math.PI/2);
          const dz = Az*fz*Math.cos(fz*u + Math.PI/3);
          const dlen = Math.max(1e-6, Math.hypot(dx,dy,dz));
          const du_dt = v / dlen;
          return du_dt * dt;
        },

        setKeyframes(arr){
          this.curve=new SpeedCurve({mode:'keyframes',keyframes:arr});
          this.el.setAttribute('motion-with-speedcurve','mode','keyframes');
        }
      });

      // ---------- 简易 UI ----------
      window.addEventListener('DOMContentLoaded', ()=>{
        const ball = document.querySelector('#ball');

        const mode = document.getElementById('mode');
        const base = document.getElementById('base'), baseVal=document.getElementById('baseVal');
        const amp  = document.getElementById('amp'),  ampVal =document.getElementById('ampVal');
        const freq = document.getElementById('freq'), freqVal=document.getElementById('freqVal');
        const phase= document.getElementById('phase'),phaseVal=document.getElementById('phaseVal');

        const traj = document.getElementById('traj');
        const radius=document.getElementById('radius');
        const lAx=document.getElementById('lAx'), lAy=document.getElementById('lAy'), lAz=document.getElementById('lAz');
        const lFx=document.getElementById('lFx'), lFy=document.getElementById('lFy'), lFz=document.getElementById('lFz');
        const useB=document.getElementById('useB');
        const bx=document.getElementById('bx'), by=document.getElementById('by'), bz=document.getElementById('bz');

        const kfArea=document.getElementById('kfjson'), kfBtn=document.getElementById('applyKf'), kfMsg=document.getElementById('kfmsg');

        function applySpeed(){
          ball.setAttribute('motion-with-speedcurve',{
            mode:mode.value,
            base:parseFloat(base.value),
            amp:parseFloat(amp.value),
            freq:parseFloat(freq.value),
            phase:parseFloat(phase.value)
          });
          baseVal.textContent=base.value; ampVal.textContent=amp.value;
          freqVal.textContent=freq.value; phaseVal.textContent=phase.value;
        }
        [mode,base,amp,freq,phase].forEach(el=>el.addEventListener('input',applySpeed));
        applySpeed();

        function applyTraj(){
          const data={
            trajectory: traj.value,
            radius: parseFloat(radius.value),
            lAx:parseFloat(lAx.value), lAy:parseFloat(lAy.value), lAz:parseFloat(lAz.value),
            lFx:parseFloat(lFx.value), lFy:parseFloat(lFy.value), lFz:parseFloat(lFz.value),
            useBounds: useB.checked,
            bounds: `${parseFloat(bx.value)} ${parseFloat(by.value)} ${parseFloat(bz.value)}`
          };
          ball.setAttribute('motion-with-speedcurve', data);
        }
        [traj,radius,lAx,lAy,lAz,lFx,lFy,lFz,useB,bx,by,bz].forEach(el=>el.addEventListener('input',applyTraj));
        applyTraj();

        kfBtn.addEventListener('click', ()=>{
          try{
            const arr=JSON.parse(kfArea.value);
            if(!Array.isArray(arr)) throw new Error('需要数组');
            for(const p of arr){
              if(!Array.isArray(p)||p.length!==2) throw new Error('每个关键帧应为 [timeSec, speed]');
              if(typeof p[0]!=='number'||typeof p[1]!=='number') throw new Error('time/speed 必须是数字');
              if(p[0]<0||p[1]<0) throw new Error('time/speed 不能为负');
            }
            ball.components['motion-with-speedcurve'].setKeyframes(arr);
            kfMsg.textContent='已应用关键帧 ✅'; kfMsg.className='ok';
            mode.value='keyframes';
          }catch(e){
            kfMsg.textContent='关键帧 JSON 有误：'+e.message; kfMsg.className='err';
          }
        });
      });
    </script>
  </head>

  <body>
    <!-- 控制面板 -->
    <div class="panel">
      <div class="row">
        <label>轨迹 (trajectory)</label>
        <select id="traj">
          <option value="circle">circle（圆周）</option>
          <option value="lissajous">lissajous（三维）</option>
          <option value="spline">spline（样条/路标）</option>
          <option value="random">random（边界盒反弹）</option>
        </select>
      </div>

      <div class="grid">
        <div class="row">
          <label>circle 半径 r</label>
          <input id="radius" type="number" step="0.1" value="1.4">
        </div>
        <div class="row">
          <label>边界启用（random）</label>
          <input id="useB" type="checkbox" checked>
        </div>
        <div class="row">
          <label>bounds X</label><input id="bx" type="number" step="0.1" value="3">
        </div>
        <div class="row">
          <label>bounds Y</label><input id="by" type="number" step="0.1" value="1.5">
        </div>
        <div class="row">
          <label>bounds Z</label><input id="bz" type="number" step="0.1" value="3">
        </div>
      </div>

      <div class="row"><label>Lissajous 振幅 (Ax,Ay,Az)</label>
        <div class="grid">
          <input id="lAx" type="number" step="0.1" value="1.2">
          <input id="lAy" type="number" step="0.1" value="0.8">
        </div>
        <input id="lAz" type="number" step="0.1" value="1.0">
      </div>
      <div class="row"><label>Lissajous 频率 (fx,fy,fz)</label>
        <div class="grid">
          <input id="lFx" type="number" step="0.1" value="1.0">
          <input id="lFy" type="number" step="0.1" value="1.5">
        </div>
        <input id="lFz" type="number" step="0.1" value="0.6">
      </div>

      <div class="row">
        <label>速度曲线模式</label>
        <select id="mode">
          <option value="constant">constant（常数）</option>
          <option value="sine">sine（正弦）</option>
          <option value="keyframes">keyframes（关键帧）</option>
        </select>
      </div>
      <div class="row"><label>base 速度（m/s）：<span id="baseVal">1.2</span></label>
        <input id="base" type="range" min="0" max="5" step="0.1" value="1.2">
      </div>
      <div class="row"><label>amp 幅度（m/s）：<span id="ampVal">0.6</span></label>
        <input id="amp" type="range" min="0" max="5" step="0.1" value="0.6">
      </div>
      <div class="row"><label>freq 频率（Hz）：<span id="freqVal">0.5</span></label>
        <input id="freq" type="range" min="0" max="2" step="0.05" value="0.5">
      </div>
      <div class="row"><label>phase 相位（rad）：<span id="phaseVal">0.0</span></label>
        <input id="phase" type="range" min="-6.283" max="6.283" step="0.01" value="0.0">
      </div>

      <div class="row">
        <label>关键帧 JSON（[timeSec, speed]，线性插值，循环）</label>
        <textarea id="kfjson">[
  [0.0, 0.6],
  [1.0, 2.0],
  [2.0, 0.8],
  [3.0, 3.5]
]</textarea>
        <div class="row">
          <button id="applyKf">应用关键帧</button>
          <span id="kfmsg" class="muted">点击生效</span>
        </div>
      </div>

      <div class="row muted">提示：spline 需要下方 #waypoints 中的路标点；随机轨迹会在 bounds 盒子中反弹。</div>
    </div>

    <!-- 场景 -->
    <a-scene renderer="colorManagement:true" xr-mode-ui="enabled: true">
      <a-entity position="0 1.6 0" camera look-controls wasd-controls="acceleration:0"></a-entity>
      <a-sky color="#ECECEC"></a-sky>
      <a-plane rotation="-90 0 0" width="20" height="20" color="#CFCFCF"></a-plane>

      <!-- 样条路标（spline 轨迹可用；你可以移动/增删这些点） -->
      <a-entity id="waypoints" position="0 1 -2" visible="false">
        <a-entity position="-1 0  0"></a-entity>
        <a-entity position=" 1 0  0"></a-entity>
        <a-entity position=" 1 0 -2"></a-entity>
        <a-entity position="-1 0 -2"></a-entity>
      </a-entity>

      <!-- 小球（含：起点、跳出、寿命） -->
      <a-sphere id="ball" radius="0.12" color="#4CC3D9"
        motion-with-speedcurve="
          trajectory: circle;
          startPos: -0.3 0.2 1.5;    /* 初始点：聊天框左上 */
          useStartPos: true;
          launch: true;              /* 先沿 -Z 跳出 */
          launchDuration: 0.6;
          launchDistance: 0.5;
          lifetimeMin: 3;            /* 3–6 秒后自动消失 */
          lifetimeMax: 6;
          vanishAction: remove;
          center: 0 1.2 -2;          /* 轨迹中心（已在 init 中移到跳出后位置） */
          radius: 1.4;
          mode: constant; base: 1.2; amp: 0.6; freq: 0.5; phase: 0.0;
          useBounds: true; bounds: 3 1.5 3;">
      </a-sphere>
    </a-scene>
  </body>
</html>
